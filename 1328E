#include <bits/stdc++.h>
#define sz(x) int(x.size())
#define ll long long
#define vi vector<int>
#define vvi vector<vi>
#define vll vector<ll>
#define fore(i,a,b) for(int i=a;i<b;i++)
#define mp make_pair
#define fst first
#define snd second
#define pb push_back
using namespace std;
int n,m,N=1,e_size;
vvi adj;
vi euler,h;
struct st{
	int val,pos;	
};
vector<bool> visited;
vector<st> ST;
map<int,int> pos_eu;
void dfs(int node,int hight){
	visited[node]=true;
	euler.pb(node);
	h.pb(hight);
	for(auto to:adj[node]) if(!visited[to]) {
		dfs(to,hight+1);
		euler.pb(node);
		h.pb(hight);
	}
}
int izq(int i){
	return i<<1;
}
int der(int i){
	return i<<1 +1;
}
st get_mini(int A,int B,int a,int b,int x){
	if(B<=a or A>=b) return {INT_MAX,-1};
	else if(a<=A and B<=b){
		return ST[x];
	}
	st p1=get_mini(A,(A+B)/2,a,b,izq(x)),p2=get_mini((A+B)/2,B,a,b,der(x));
	if(p1.val<p2.val) return 
}
void get_lca(int v1,int v2){
	int l=min(pos_eu[v1],pos_eu[v2]),r=max(pos_eu[v1],pos_eu[v2])+1;
	return euler[get_mini(0,N,l,r,1).val];
}
int main() {
	cin>>n>>m;
	adj.resize(n+1);
	fore(i,0,m){
		int x,y;
		cin>>x>>y;
		adj[x].pb(y);
		adj[y].pb(x);
	}
	visited.resize(n+1,false);
	dfs(1,0);
	e_size=sz(euler);
	fore(i,0,e_size){
		if(pos_eu[euler[i]]!=0 or euler[i]==1) continue;
		pos_eu[euler[i]]=i;
	}
	while(N<e_size) N*=2;
	ST.resize(N*2);
	fore(i,N,2*N){
		if(i<N+e_size) ST[i]={h[i-N],i-N};
		else ST[i]={INT_MAX,i-N};
	}
	for(int i=N-1;i>0;i--){
		if(ST[izq(i)].val<ST[der(i)].val) ST[i]=ST[izq(i)];
		else ST[i]=ST[der(i)];
	}
	int k;
	while(cin>>k){
		
	}
	return 0;
}
